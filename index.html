<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>Improv Timer</title>
<style>
  :root{
    --yellow:#ffd400;
    --green:#1db954;
    --blue:#66d1ff; /* light blue */
    --bg:#000000;
    --fg:#ffffff;
    --danger:#ff2222;
  }

  html,body{
    height:100%;
    margin:0;
    background:var(--bg);
    color:var(--fg);
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif;
    overflow:hidden;
  }

  /* App layout */
  .app{
    position:relative;
    height:100%;
    width:100%;
    display:flex;
    flex-direction:column;
  }

  /* Progress field fills left→right with the active colors */
  .field{
    position:relative;
    flex:1 1 auto;
    overflow:hidden;
    background: var(--bg);
  }

  /* The colored fill shows only up to .fill width; its own background is a gradient sized by segment ratios */
  .gradient{
    position:absolute;
    inset:0;
    pointer-events:none;
    /* background set dynamically */
  }
  .fill{
    position:absolute;
    inset:0;
    width:0%;
    overflow:hidden;
  }
  .fill .gradient{
    position:absolute;
    inset:0;
  }

  /* Large stopwatch centered */
  .time{
    position:absolute;
    inset:0;
    display:flex;
    align-items:center;
    justify-content:center;
    text-align:center;
    line-height:1;
    font-weight:800;
    /* Responsive, huge: scales with width but capped by height */
    font-size: clamp(40px, 22vw, 28vh);
    letter-spacing: 0.02em;
    text-shadow: 0 0 18px rgba(0,0,0,.65);
    z-index:3;
    user-select:none;
  }

  /* Blinking overlays */
  .blink-mask{
    position:absolute; inset:0; background:rgba(255,255,255,0.0); pointer-events:none; z-index:4;
  }
  .blink-on{
    animation: blinkOn 1s steps(2, jump-none) infinite;
  }
  @keyframes blinkOn{
    0%{ opacity:0; }
    49.99%{ opacity:0; }
    50%{ opacity:1; }
    100%{ opacity:1; }
  }

  /* End-of-timer black/red blink (on top) */
  .end-blink{
    position:absolute; inset:0; pointer-events:none; z-index:5;
    background: var(--bg);
    animation: endBlink 0.5s steps(2, jump-none) infinite;
  }
  @keyframes endBlink{
    0%{ background: var(--bg); }
    50%{ background: var(--danger); }
    100%{ background: var(--danger); }
  }

  /* Bottom controls/status bar */
  .bar{
    flex:0 0 auto;
    padding: 10px 14px;
    display:flex;
    align-items:center;
    gap:10px;
    background: rgba(0,0,0,0.55);
    backdrop-filter: blur(4px);
    border-top: 1px solid rgba(255,255,255,0.08);
    font-size: clamp(12px, 2.4vw, 18px);
  }
  .pill{
    padding:6px 10px; border:1px solid rgba(255,255,255,0.18); border-radius:999px;
    display:inline-flex; align-items:center; gap:8px; white-space:nowrap;
  }
  .dot{ width:10px; height:10px; border-radius:50%; display:inline-block; }
  .dot.yellow{ background:var(--yellow); }
  .dot.green{ background:var(--green); }
  .dot.blue{ background:var(--blue); }

  .bar .spacer{ flex:1; }

  /* Floating blue settings ball */
  .fab{
    position:fixed;
    right:18px; bottom: calc(64px + 18px);
    width:64px; height:64px; border-radius:50%;
    background: var(--blue);
    color:#00324a;
    display:flex; align-items:center; justify-content:center;
    font-weight:900;
    font-size: 28px;
    box-shadow: 0 8px 24px rgba(0,0,0,.45);
    cursor:pointer; user-select:none;
    z-index:6;
    border: 2px solid rgba(255,255,255,0.3);
  }
  .fab:active{ transform: scale(0.98); }

  /* Settings sheet */
  .sheet{
    position:fixed; inset:0; background: rgba(0,0,0,0.66);
    display:none; align-items:center; justify-content:center; z-index:7;
  }
  .sheet.open{ display:flex; }
  .card{
    width:min(720px, 92vw);
    background:#0b0b0b; color:var(--fg);
    border:1px solid rgba(255,255,255,0.12);
    border-radius:16px;
    box-shadow: 0 20px 60px rgba(0,0,0,.6);
    padding: 18px;
  }
  .row{ display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
  .row + .row{ margin-top:12px; }
  label{
    display:flex; align-items:center; gap:8px;
    background:#121212; border:1px solid rgba(255,255,255,0.14);
    border-radius:12px; padding:10px 12px;
  }
  input[type=number]{
    width:80px; padding:8px 10px; border-radius:8px; border:1px solid rgba(255,255,255,0.2);
    background:#0c0c0c; color:var(--fg); font-size:16px;
    -moz-appearance: textfield;
  }
  input::-webkit-outer-spin-button,input::-webkit-inner-spin-button{ -webkit-appearance: none; margin:0; }

  .btn{
    border:1px solid rgba(255,255,255,0.18);
    background:#101010; color:var(--fg);
    padding:10px 14px; border-radius:12px; font-weight:700; cursor:pointer;
  }
  .btn.primary{ background:var(--blue); color:#002235; }
  .btn.warn{ background:#1a0000; color:#ffb3b3; border-color:#551111; }

  /* Small helper text */
  .hint{ opacity:0.7; font-size: 12px; }

  /* Top overlay buttons (Stop & Return / Start / Reset) */
  .top-controls{
    position:fixed; top:12px; left:12px; right:12px; display:flex; gap:10px; z-index:6;
    pointer-events:none;
  }
  .top-controls .btn{ pointer-events:auto; }
</style>
</head>
<body>
  <div class="app" id="app">
    <div class="field" id="field">
      <!-- Progressive fill -->
      <div class="fill" id="fill">
        <div class="gradient" id="gradient"></div>
      </div>

      <!-- Blink overlays -->
      <div class="blink-mask" id="blinkMask" style="display:none;"></div>
      <div class="end-blink" id="endBlink" style="display:none;"></div>

      <!-- Stopwatch text -->
      <div class="time" id="clock">0:00</div>
    </div>

    <!-- Top controls -->
    <div class="top-controls">
      <button class="btn" id="startBtn">Start</button>
      <button class="btn" id="stopReturnBtn">Stop &amp; Return</button>
      <button class="btn warn" id="resetBtn" title="Triple-click to reset">Reset ×3</button>
    </div>

    <!-- Bottom status bar -->
    <div class="bar">
      <span class="pill"><span class="dot yellow"></span><span id="yShow">3m</span></span>
      <span class="pill"><span class="dot green"></span><span id="gShow">14m</span></span>
      <span class="pill"><span class="dot blue"></span><span id="bShow">3m</span></span>
      <div class="spacer"></div>
      <span class="pill" title="Total time"><strong id="totalShow">20m</strong></span>
    </div>

    <!-- Blue settings ball -->
    <div class="fab" id="settingsFab" title="Settings">⚙️</div>

    <!-- Settings sheet -->
    <div class="sheet" id="sheet">
      <div class="card">
        <h2 style="margin:6px 2px 12px 2px;">Improv Timer Settings</h2>
        <div class="row">
          <label><span class="dot yellow"></span> Yellow (min)
            <input id="yellowInput" type="number" min="0" max="300" value="3" />
          </label>
          <label><span class="dot green"></span> Green (min)
            <input id="greenInput" type="number" min="0" max="300" value="14" />
          </label>
          <label><span class="dot blue"></span> Light Blue (min)
            <input id="blueInput" type="number" min="0" max="300" value="3" />
          </label>
        </div>

        <div class="row">
          <button class="btn primary" id="saveAndReturn">Save &amp; Return</button>
          <button class="btn" id="closeSheet">Cancel</button>
          <span class="spacer"></span>
          <span class="hint">Tip: Reset requires <strong>triple-click</strong>. Stopwatch counts up from 0.</span>
        </div>
      </div>
    </div>
  </div>

<script>
(function(){
  // Elements
  const clock = document.getElementById('clock');
  const field = document.getElementById('field');
  const fill = document.getElementById('fill');
  const gradient = document.getElementById('gradient');
  const blinkMask = document.getElementById('blinkMask');
  const endBlink = document.getElementById('endBlink');

  const yShow = document.getElementById('yShow');
  const gShow = document.getElementById('gShow');
  const bShow = document.getElementById('bShow');
  const totalShow = document.getElementById('totalShow');

  const startBtn = document.getElementById('startBtn');
  const stopReturnBtn = document.getElementById('stopReturnBtn');
  const resetBtn = document.getElementById('resetBtn');

  const fab = document.getElementById('settingsFab');
  const sheet = document.getElementById('sheet');
  const saveAndReturn = document.getElementById('saveAndReturn');
  const closeSheet = document.getElementById('closeSheet');

  const yellowInput = document.getElementById('yellowInput');
  const greenInput  = document.getElementById('greenInput');
  const blueInput   = document.getElementById('blueInput');

  // State
  let yellowMin = 3, greenMin = 14, blueMin = 3;
  let yellowSec = yellowMin*60, greenSec = greenMin*60, blueSec = blueMin*60;
  let totalSec  = yellowSec + greenSec + blueSec;

  let elapsed = 0; // seconds (counts up)
  let running = false;
  let rafId = null;
  let lastTick = null;

  // Blink logic for blue segment
  let scheduledBlueBlinks = new Set(); // which minute marks have already triggered
  let blinking = false; // are we currently performing a blink sequence
  let endBlinking = false;

  // Reset UI texts
  function refreshLabels(){
    yShow.textContent = `${yellowMin}m`;
    gShow.textContent = `${greenMin}m`;
    bShow.textContent = `${blueMin}m`;
    totalShow.textContent = `${yellowMin+greenMin+blueMin}m`;

    // Build gradient stops (0..100%) for the full width
    const yFrac = totalSec ? (yellowSec/totalSec)*100 : 0;
    const gFrac = totalSec ? (greenSec/totalSec)*100 : 0;
    const bFrac = 100 - yFrac - gFrac;

    gradient.style.background = `linear-gradient(to right,
      var(--yellow) 0% ${yFrac}%,
      var(--green) ${yFrac}% ${yFrac+gFrac}%,
      var(--blue) ${yFrac+gFrac}% 100%
    )`;
  }

  function openSettings(){ sheet.classList.add('open'); }
  function closeSettings(){ sheet.classList.remove('open'); }

  // Stopwatch display mm:ss
  function fmt(t){
    if (t < 0) t = 0;
    const m = Math.floor(t/60);
    const s = Math.floor(t%60);
    return `${m}:${s.toString().padStart(2,'0')}`;
  }

  function setFillByElapsed(sec){
    const pct = Math.min(100, Math.max(0, (sec / Math.max(1,totalSec))*100));
    fill.style.width = pct + '%';
  }

  function resetTimer(keepTimes=false){
    stop();
    elapsed = 0;
    lastTick = null;
    scheduledBlueBlinks.clear();
    blinking = false;
    blinkMask.style.display = 'none';
    endBlinking = false;
    endBlink.style.display = 'none';
    setFillByElapsed(0);
    clock.textContent = fmt(0);
    if (!keepTimes){
      yellowMin = clampInt(+yellowInput.value || 0, 0, 300);
      greenMin  = clampInt(+greenInput.value  || 0, 0, 300);
      blueMin   = clampInt(+blueInput.value   || 0, 0, 300);
    }
    yellowSec = yellowMin*60;
    greenSec  = greenMin*60;
    blueSec   = blueMin*60;
    totalSec  = yellowSec + greenSec + blueSec;
    refreshLabels();
  }

  function start(){
    if (running || totalSec === 0) return;
    running = true;
    endBlinking = false;
    endBlink.style.display = 'none';
    lastTick = performance.now();
    tick();
  }
  function stop(){
    running = false;
    if (rafId) {
      cancelAnimationFrame(rafId);
      rafId = null;
    }
  }

  function tick(now){
    if (!running) return;
    if (!now) now = performance.now();
    const dt = (now - lastTick) / 1000;
    if (dt >= 0.25) {
      // accumulate whole seconds smoothly
      const add = Math.floor(dt);
      elapsed += add;
      lastTick += add*1000;
      // Update visuals & events
      if (elapsed <= totalSec){
        clock.textContent = fmt(elapsed);
        setFillByElapsed(elapsed);
        handleBlueBlinkScheduling();
        if (elapsed === totalSec){
          // finished
          running = false;
          endBlinking = true;
          endBlink.style.display = 'block';
          return; // stop advancing
        }
      }
    }
    rafId = requestAnimationFrame(tick);
  }

  function clampInt(n,min,max){ return Math.max(min, Math.min(max, Math.round(n))); }

  // Blue segment blink rules:
  // When in blue phase, at each whole minute remaining (k = 1..blueMin),
  // blink k times (1s per blink). Example: 3m left → blink 3 times.
  async function handleBlueBlinkScheduling(){
    const passed = elapsed;
    if (passed < yellowSec + greenSec || passed >= totalSec) return;

    const blueElapsed = passed - (yellowSec + greenSec);
    const remaining = blueSec - blueElapsed; // seconds remaining in blue
    const wholeMinLeft = Math.ceil(remaining / 60); // minutes left (1..blueMin)

    // Trigger only when we're exactly at a minute boundary in wall time:
    const atBoundary = (remaining % 60 === 0);
    if (atBoundary && wholeMinLeft > 0 && !scheduledBlueBlinks.has(wholeMinLeft)){
      scheduledBlueBlinks.add(wholeMinLeft);
      queueBlinkSequence(wholeMinLeft);
    }
  }

  function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

  async function queueBlinkSequence(n){
    // If a sequence is already running, chain after it.
    // We'll run them serially (rare overlap).
    while (blinking) { await sleep(50); }
    blinking = true;
    blinkMask.style.display = 'block';
    for (let i=0;i<n;i++){
      blinkMask.classList.add('blink-on');
      await sleep(1000);
      blinkMask.classList.remove('blink-on');
      // Gap between blinks (0.15s)
      if (i < n-1) await sleep(150);
    }
    blinkMask.style.display = 'none';
    blinking = false;
  }

  // Controls
  startBtn.addEventListener('click', ()=>{
    closeSettings();
    start();
  });
  stopReturnBtn.addEventListener('click', ()=>{
    stop();
    openSettings();
  });

  // Triple-click reset
  let clicks = 0, clickTimer = null;
  resetBtn.addEventListener('click', ()=>{
    clicks++;
    if (clicks === 1){
      clickTimer = setTimeout(()=>{ clicks=0; }, 900);
    }
    if (clicks >= 3){
      clearTimeout(clickTimer);
      clicks = 0;
      resetTimer(true); // keep current times
    }
  });

  // Settings ball
  fab.addEventListener('click', ()=>{
    if (sheet.classList.contains('open')) {
      // Save & Return action if already open
      saveTimes();
      closeSettings();
    } else {
      openSettings();
    }
  });

  // Sheet buttons
  saveAndReturn.addEventListener('click', ()=>{
    saveTimes();
    closeSettings();
  });
  closeSheet.addEventListener('click', closeSettings);

  function saveTimes(){
    const y = clampInt(+yellowInput.value || 0, 0, 300);
    const g = clampInt(+greenInput.value  || 0, 0, 300);
    const b = clampInt(+blueInput.value   || 0, 0, 300);
    yellowMin = y; greenMin = g; blueMin = b;
    yellowSec = y*60; greenSec = g*60; blueSec = b*60;
    totalSec = yellowSec + greenSec + blueSec;
    scheduledBlueBlinks.clear();
    refreshLabels();
    // Recompute clock/fill relative to 0
    elapsed = 0;
    setFillByElapsed(0);
    clock.textContent = fmt(0);
    endBlink.style.display = 'none';
  }

  // Initial
  refreshLabels();
  setFillByElapsed(0);

  // Orientation hint (optional): ensure landscape looks good
  window.addEventListener('resize', ()=>{
    // no-op, layout is responsive
  });

  // Keyboard helpers (optional)
  window.addEventListener('keydown', (e)=>{
    if (e.key === ' ') { // space toggles start/stop
      e.preventDefault();
      running ? stop() : start();
    } else if (e.key.toLowerCase() === 'r') {
      resetTimer(true);
    } else if (e.key.toLowerCase() === 's') {
      openSettings();
    }
  });
})();
</script>
</body>
</html>
